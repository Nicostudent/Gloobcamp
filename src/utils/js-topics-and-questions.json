[
  {
    "id": "1",
    "title": "Execution Context in JavaScript",
    "content": "The execution context is the environment in which JavaScript code is evaluated and executed. When the browser (or the JavaScript runtime environment) starts executing your code, it first enters a global execution context. This context is created before any code is executed and handles the execution of the entire script. Every time a function is called, a new execution context is created for that function. This execution context has two phases: the creation phase and the execution phase. During the creation phase, the JavaScript engine scans the code and allocates memory for variables and functions. This process is called 'hoisting,' which means that variable and function declarations are lifted to the top of their execution context. Variables declared with `var` are initialized with the value `undefined` during hoisting. This means that you can reference a variable before its declaration in the code, but if you try to use it before it is assigned a value, you will get `undefined`. Function declarations are also 'hoisted,' and their full definition is placed at the top of the context, allowing functions to be called before their declaration in the code. However, function expressions and variables declared with `let` and `const` are not initialized during hoisting and cannot be used before their declaration. In the execution phase, the engine executes the code line by line. Understanding how hoisting works is important to avoid unexpected errors and to better understand how JavaScript manages execution context and the scope of variables and functions.",
    "questions": [
      {
        "question": "What is an execution context in JavaScript?",
        "choices": [
          "A variable within a function",
          "The environment where the code is evaluated and executed",
          "A data structure",
          "A global function"
        ],
        "correctAnswer": "The environment where the code is evaluated and executed"
      },
      {
        "question": "How many execution contexts exist in a JavaScript application?",
        "choices": [
          "Only one, the global context",
          "One for each function",
          "One for each variable",
          "Two, the global and the function context"
        ],
        "correctAnswer": "One for each function"
      },
      {
        "question": "What does 'hoisting' mean in JavaScript?",
        "choices": [
          "Assigning values to variables",
          "Lifting variable and function declarations to the top of the execution context",
          "Executing the code line by line",
          "Creating a new execution context"
        ],
        "correctAnswer": "Lifting variable and function declarations to the top of the execution context"
      }
    ],
    "image": "/path/to/image1.jpg",
    "path": "/execution-context"
  },
  {
    "id": "2",
    "title": "Differences between var, let, and const",
    "content": "In JavaScript, `var`, `let`, and `const` are used to declare variables, but they have important differences in their behavior and scope.\n\n1. **`var`**:\n   - **Scope**: Variables declared with `var` have function scope. This means that if you declare a variable with `var` inside a function, it will be available throughout the function but not outside of it. If `var` is declared outside of any function, it has a global scope.\n   - **Hoisting**: Variables declared with `var` are hoisted to the beginning of their execution context. This means you can use a variable declared with `var` before its declaration, although its value will be `undefined` until it is assigned a value in the code.\n   - **Reassignment and Redeclaration**: Variables declared with `var` can be reassigned and redeclared within their scope without errors.\n\n 2. **`let`**:\n   - **Scope**: Variables declared with `let` have block scope. A block is defined by curly braces `{}`. This means that a `let` variable is available only within the block in which it is declared, including any nested blocks.\n   - **Hoisting**: Although `let` variables are hoisted to the beginning of their block, they cannot be used before their declaration in the code. Attempting to do so will result in a reference error.\n   - **Reassignment and Redeclaration**: `let` variables can be reassigned but cannot be redeclared within the same block.\n\n3. **`const`**:\n   - **Scope**: Similar to `let`, variables declared with `const` have block scope.\n   - **Hoisting**: Like `let`, `const` variables are hoisted to the beginning of their block, but they cannot be used before their declaration.\n   - **Reassignment and Redeclaration**: `const` variables cannot be reassigned or redeclared. Once a `const` variable is assigned, its value cannot be changed. This makes `const` ideal for values that should not change throughout the execution of the program.\n   - **Immutability**: It's important to note that `const` does not make the assigned value immutable. If `const` is used to assign an object or an array, the properties of the object or the elements of the array can be modified.",
    "questions": [
      {
        "question": "What is the scope of a variable declared with `var`?",
        "choices": ["Global", "Function", "Block", "Local"],
        "correctAnswer": "Function"
      },
      {
        "question": "What happens if you try to use a `let` variable before its declaration?",
        "choices": [
          "It initializes with `undefined`",
          "It causes a reference error",
          "It initializes with `null`",
          "The declaration is ignored"
        ],
        "correctAnswer": "It causes a reference error"
      },
      {
        "question": "Can a variable declared with `const` be reassigned?",
        "choices": ["Yes", "No"],
        "correctAnswer": "No"
      },
      {
        "question": "What does it mean for `let` and `const` declarations to have block scope?",
        "choices": [
          "They are available only within the block in which they are declared",
          "They can be used anywhere in the code",
          "They cannot be used before their declaration",
          "They are available throughout the function"
        ],
        "correctAnswer": "They are available only within the block in which they are declared"
      }
    ],
    "image": "/path/to/image2.jpg",
    "path": "/var-let-const"
  },
  {
    "id": "3",
    "title": "The `this` Keyword in JavaScript",
    "content": "In JavaScript, the `this` keyword is a fundamental concept that refers to the execution context in which a function is called. The value of `this` depends on how the function is invoked. Here are some general rules:\n\n1. **In the global context**: When `this` is used in the global context (outside of any function), it refers to the global object (`window` in browsers).\n\n2. **In an object method**: When `this` is used inside an object method, it refers to the object to which the method belongs.\n\n3. **In a regular function**: In a regular function, the value of `this` depends on how the function is called. By default, in strict mode, `this` will be `undefined`. In non-strict mode, `this` will be the global object.\n\n4. **In a constructor**: When `this` is used in a constructor function (a function called with the `new` keyword), it refers to the new object being created.\n\n5. **In an arrow function**: Arrow functions (`=>`) do not have their own `this` value. Instead, they inherit the `this` value from the context in which they are defined. This means that the value of `this` inside an arrow function is the same as the value of `this` outside the arrow function.\n\nUnderstanding how `this` works is crucial for writing and debugging JavaScript code effectively.",
    "questions": [
      {
        "question": "What does `this` refer to in the global context?",
        "choices": [
          "`undefined`",
          "The global object",
          "The object to which the method belongs",
          "A new object"
        ],
        "correctAnswer": "The global object"
      },
      {
        "question": "What value does `this` take in an arrow function?",
        "choices": [
          "The global object",
          "The object to which the method belongs",
          "`undefined`",
          "It inherits the value of `this` from the context in which it is defined"
        ],
        "correctAnswer": "It inherits the value of `this` from the context in which it is defined"
      },
      {
        "question": "What value does `this` take in an object method?",
        "choices": [
          "`undefined`",
          "The global object",
          "The object to which the method belongs",
          "A new object"
        ],
        "correctAnswer": "The object to which the method belongs"
      },
      {
        "question": "What value does `this` take in a constructor function?",
        "choices": [
          "`undefined`",
          "The global object",
          "The object to which the method belongs",
          "A new object"
        ],
        "correctAnswer": "A new object"
      }
    ],
    "image": "/path/to/image3.jpg",
    "path": "/this-keyword"
  },
  {
    "id": "4",
    "title": "Asynchronous JavaScript: From Callbacks to Async/Await",
    "content": "Asynchronous programming in JavaScript has evolved significantly over time. Here we explore key concepts and their evolution, from callbacks to async/await.\n\n1. **Callbacks**: Callbacks are functions that are passed as arguments to other functions and are executed after an asynchronous operation has completed. While callbacks allow handling asynchronous operations, they can lead to code that is difficult to read and maintain, especially when many callbacks are nested.\n\n2. **Callback Hell**: Also known as the 'pyramid of doom', this occurs when multiple callbacks are nested within other callbacks. This makes the code difficult to read, understand, and debug. As complexity increases, the code becomes more error-prone.\n\n3. **Promises**: Promises represent the result of an asynchronous operation that may complete in the future. Promises provide a more structured way to handle the result of an asynchronous operation, allowing chaining operations using `then()` and handling errors with `catch()`. This improves code readability and maintainability compared to callbacks.\n\n4. **Async/Await**: Introduced in ECMAScript 2017, `async/await` further simplifies handling asynchronous operations. `async` turns a function into an asynchronous function, which always returns a promise. Within an `async` function, `await` can be used to wait for a promise to resolve, allowing writing asynchronous code that resembles synchronous code in structure. This makes the code more readable and intuitive for handling errors.",
    "questions": [
      {
        "question": "What is a callback in JavaScript?",
        "choices": [
          "A function that is passed as an argument and is executed after an asynchronous operation completes",
          "A function that runs immediately without waiting",
          "An object that represents an asynchronous operation",
          "A data structure that stores asynchronous functions"
        ],
        "correctAnswer": "A function that is passed as an argument and is executed after an asynchronous operation completes"
      },
      {
        "question": "What is 'callback hell'?",
        "choices": [
          "The use of multiple nested callbacks, making the code difficult to read",
          "A type of error in promises",
          "A problem with synchronous functions",
          "A technique for efficiently handling asynchronous operations"
        ],
        "correctAnswer": "The use of multiple nested callbacks, making the code difficult to read"
      },
      {
        "question": "What is a promise in JavaScript?",
        "choices": [
          "An object that represents the result of an asynchronous operation that may complete in the future",
          "A function that runs at the end of a synchronous operation",
          "A type of callback",
          "A data structure that stores asynchronous operations"
        ],
        "correctAnswer": "An object that represents the result of an asynchronous operation that may complete in the future"
      },
      {
        "question": "How does 'async/await' simplify handling asynchronous operations?",
        "choices": [
          "It allows writing asynchronous code that resembles synchronous code, improving readability",
          "It eliminates the need to handle errors in asynchronous operations",
          "It completely replaces promises",
          "It nests multiple callbacks in asynchronous functions"
        ],
        "correctAnswer": "It allows writing asynchronous code that resembles synchronous code, improving readability"
      }
    ],
    "image": "/path/to/image5.jpg",
    "path": "/async-await"
  },
  {
    "id": "5",
    "title": "JavaScript Asíncrono: De Callbacks a Async/Await",
    "content": "La programación asíncrona en JavaScript ha evolucionado significativamente a lo largo del tiempo. Aquí exploramos los conceptos clave y su evolución, desde los callbacks hasta async/await.\n  \n   1. **Callbacks**: Los callbacks son funciones que se pasan como argumentos a otras funciones y se ejecutan después de que una operación asíncrona ha finalizado. Aunque los callbacks permiten manejar operaciones asíncronas, pueden llevar a un código difícil de leer y mantener, especialmente cuando se anidan muchos callbacks.\n  \n   2. **Callback Hell**: También conocido como 'pyramid of doom', ocurre cuando se anidan múltiples callbacks dentro de otros callbacks. Esto hace que el código sea difícil de leer, entender y depurar. A medida que la complejidad aumenta, el código se vuelve más propenso a errores.\n  \n   3. **Promises**: Las promesas representan el resultado de una operación asíncrona que puede completarse en el futuro. Las promesas proporcionan una forma más estructurada de manejar el resultado de una operación asíncrona, permitiendo encadenar operaciones usando `then()` y manejar errores con `catch()`. Esto mejora la legibilidad y el mantenimiento del código en comparación con los callbacks.\n  \n   4. **Async/Await**: Introducido en ECMAScript 2017, `async/await` simplifica aún más el manejo de operaciones asíncronas. `async` convierte una función en una función asincrónica, que siempre devuelve una promesa. Dentro de una función `async`, se puede usar `await` para esperar a que una promesa se resuelva, lo que permite escribir código asíncrono que se asemeja al código síncrono en su estructura. Esto facilita la lectura y el manejo de errores de manera más intuitiva.",
    "questions": [
      {
        "question": "What is the prototype of an object in JavaScript?",
        "choices": [
          "The object the current object refers to for inheriting properties and methods",
          "A property that stores specific data of the object",
          "A function used to create new objects",
          "A data structure for storing methods"
        ],
        "correctAnswer": "The object the current object refers to for inheriting properties and methods"
      },
      {
        "question": "What is the prototype chain?",
        "choices": [
          "The sequence of objects through which JavaScript looks for properties and methods",
          "A set of functions that run in the correct order",
          "A list of methods that can be used on an object",
          "A data structure that contains all prototypes"
        ],
        "correctAnswer": "The sequence of objects through which JavaScript looks for properties and methods"
      },
      {
        "question": "How do you create a new object with a specific prototype?",
        "choices": [
          "Using `Object.create(proto)`",
          "Defining a constructor function",
          "Modifying the prototype of an existing object",
          "Using the `new` operator with a constructor"
        ],
        "correctAnswer": "Using `Object.create(proto)`"
      },
      {
        "question": "What is the `prototype` property in a constructor function?",
        "choices": [
          "An object that contains properties and methods inherited by objects created with the constructor function",
          "A function that defines how objects are created",
          "A method to modify the prototype of an object",
          "A property that stores specific data of each object"
        ],
        "correctAnswer": "An object that contains properties and methods inherited by objects created with the constructor function"
      }
    ],
    "image": "/path/to/image6.jpg",
    "path": "/prototypes"
  },
  {
    "id": "6",
    "title": "Inheritance in JavaScript",
    "content": "Inheritance in JavaScript allows an object to inherit properties and methods from another object. This feature is essential for creating reusable and organized code structures. Here is how inheritance works in JavaScript:\n\n1. **Prototypal Inheritance**: JavaScript uses a prototypal inheritance system. This means that objects can inherit properties and methods from other objects through the prototype chain. When an object looks for a property or method, JavaScript first checks the object itself and then follows the prototype chain until it finds the property or reaches `Object.prototype`.\n\n2. **Inheritance with Constructor Functions**: Inheritance can be implemented using constructor functions and the `prototype` object. By defining a base constructor function and extending it with a derived constructor function, objects created with the derived function inherit properties and methods from the base function. You can use `Object.create()` to explicitly establish the inheritance relationship between objects.\n\n3. **Inheritance with Classes (ES6)**: With the introduction of classes in ECMAScript 2015 (ES6), inheritance in JavaScript becomes more intuitive. Classes allow you to define a base class and extend it using the `extends` keyword. The methods and properties of the base class are automatically inherited by the derived class. The derived class can override methods of the base class and add new methods or properties.\n\n4. **`super` Keyword**: Within a derived class, you can use the `super` keyword to call the constructor and methods of the base class. This allows you to access the properties and methods of the base class from the derived class, facilitating extension and customization of functionality.\n\n5. **Composition over Inheritance**: While inheritance is powerful, it is sometimes more convenient to use composition, which involves combining objects to create new functionalities rather than relying solely on inheritance. Composition can offer greater flexibility and avoid common issues associated with complex inheritance.",
    "questions": [
      {
        "question": "How does prototypal inheritance work in JavaScript?",
        "choices": [
          "Objects inherit properties and methods through the prototype chain",
          "Objects inherit properties and methods through direct assignment",
          "Objects create a new instance of another object",
          "Objects copy properties and methods when created"
        ],
        "correctAnswer": "Objects inherit properties and methods through the prototype chain"
      },
      {
        "question": "How is inheritance established between constructor functions?",
        "choices": [
          "Using the `prototype` object and `Object.create()`",
          "Creating a constructor function within another",
          "Directly assigning properties to the constructor function",
          "Using the `extends` keyword"
        ],
        "correctAnswer": "Using the `prototype` object and `Object.create()`"
      },
      {
        "question": "What does ECMAScript 2015 (ES6) introduce to facilitate inheritance in JavaScript?",
        "choices": [
          "Classes and the `extends` keyword",
          "The `Object.create()` method",
          "Advanced constructor functions",
          "The `super` method"
        ],
        "correctAnswer": "Classes and the `extends` keyword"
      },
      {
        "question": "What is the `super` keyword used for in a derived class?",
        "choices": [
          "To call the constructor and methods of the base class",
          "To create a new instance of the base class",
          "To override methods of the base class",
          "To access private properties of the base class"
        ],
        "correctAnswer": "To call the constructor and methods of the base class"
      }
    ],
    "image": "/path/to/image7.jpg",
    "path": "/inheritance"
  },
  {
    "id": "7",
    "title": "Destructuring in JavaScript",
    "content": "Destructuring is a feature in JavaScript that allows you to extract values from arrays or objects and assign them to variables in a concise manner. Introduced in ECMAScript 2015 (ES6), destructuring makes it easier to extract and assign values without needing to access each property or index individually.\n\n1. **Array Destructuring**: Array destructuring allows you to extract elements from an array into individual variables. It uses bracket syntax to assign values to variables. For example:\n\n```javascript\nconst numbers = [1, 2, 3];\nconst [a, b, c] = numbers;\nconsole.log(a); // 1\nconsole.log(b); // 2\nconsole.log(c); // 3\n```\n\n2. **Object Destructuring**: Object destructuring allows you to extract properties from an object into individual variables. It uses curly brace syntax to assign values to variables. For example:\n\n```javascript\nconst person = { name: 'John', age: 30 };\nconst { name, age } = person;\nconsole.log(name); // John\nconsole.log(age); // 30\n```\n\n3. **Destructuring with Default Values**: You can provide default values in case the properties or elements being destructured do not exist. This prevents errors and ensures that variables have a default value. For example:\n\n```javascript\nconst numbers = [1];\nconst [a, b = 2] = numbers;\nconsole.log(a); // 1\nconsole.log(b); // 2\n```\n\n4. **Nested Destructuring**: Destructuring can also be applied to nested arrays and objects. This allows you to efficiently extract values from more complex structures. For example:\n\n```javascript\nconst user = { name: 'Alice', address: { city: 'Wonderland', zip: '12345' } };\nconst { name, address: { city } } = user;\nconsole.log(name); // Alice\nconsole.log(city); // Wonderland\n```\n\n5. **Destructuring in Function Parameters**: Destructuring can be used in function parameters to extract properties from an object or elements from an array directly in the function signature. This simplifies data manipulation in functions.\n\n```javascript\nfunction displayInfo({ name, age }) {\n  console.log(`Name: ${name}, Age: ${age}`);\n}\n\nconst person = { name: 'Bob', age: 25 };\ndisplayInfo(person); // Name: Bob, Age: 25\n```\n\nDestructuring improves code readability and facilitates the extraction and assignment of values in JavaScript.",
    "questions": [
      {
        "question": "How is array destructuring performed in JavaScript?",
        "choices": [
          "Using brackets to assign values to variables",
          "Using curly braces to extract properties",
          "Using the `Array.prototype.map()` method",
          "Calling the `Object.assign()` function"
        ],
        "correctAnswer": "Using brackets to assign values to variables"
      },
      {
        "question": "What happens if a value is not present in array destructuring and a default value is provided?",
        "choices": [
          "The variable will take the default value",
          "The code will throw an error",
          "The variable will be assigned as `undefined`",
          "The default value will be ignored"
        ],
        "correctAnswer": "The variable will take the default value"
      },
      {
        "question": "How can you perform destructuring of a nested object?",
        "choices": [
          "Using nested curly braces in the destructuring syntax",
          "Accessing nested properties with dot notation",
          "Applying destructuring inside an array",
          "Using the `Object.assign()` function"
        ],
        "correctAnswer": "Using nested curly braces in the destructuring syntax"
      },
      {
        "question": "How can destructuring be used in function parameters?",
        "choices": [
          "By destructuring an object or array directly in the function signature",
          "By assigning default values in the function body",
          "By using the `bind()` method to pass values",
          "By applying destructuring in the function's return value"
        ],
        "correctAnswer": "By destructuring an object or array directly in the function signature"
      }
    ],
    "image": "/path/to/image8.jpg",
    "path": "/descrtucturing"
  },
  {
    "id": "8",
    "title": "Arrow Functions in JavaScript",
    "content": "Arrow functions were introduced in ECMAScript 2015 (ES6) and provide a more concise syntax for writing functions in JavaScript. In addition to their compact syntax, arrow functions have specific behaviors regarding `this` and other aspects. Here's how arrow functions work:\n\n1. **Syntax**: Arrow functions have a shorter syntax compared to traditional functions. They use the `=>` notation instead of `function`. For example:\n\n```javascript\n// Traditional function\nfunction add(a, b) {\n  return a + b;\n}\n\n// Arrow function\nconst add = (a, b) => a + b;\n```\n\n2. **`this` Scope**: Unlike traditional functions, arrow functions do not have their own `this`. Instead, they inherit the `this` from the context in which they were defined. This makes them useful for working with methods in objects or in callbacks where you want `this` to refer to the outer object or the surrounding function's context.\n\n```javascript\nfunction Timer() {\n  this.seconds = 0;\n  setInterval(() => this.seconds++, 1000);\n}\n\nconst timer = new Timer();\n```\n\n3. **Arrow Functions with a Single Parameter**: If an arrow function has a single parameter, you can omit the parentheses around the parameter. For example:\n\n```javascript\nconst square = x => x * x;\n```\n\n4. **Arrow Functions with a Code Block**: If the arrow function has more than one expression or needs to perform multiple operations, you should use a code block `{}` and the `return` keyword to return a value.\n\n```javascript\nconst add = (a, b) => {\n  const sum = a + b;\n  return sum;\n};\n```\n\n5. **Arrow Functions and `arguments`**: Arrow functions do not have an `arguments` object. If you need to access the arguments passed to the function, you should use a traditional function or the rest operator (`...args`).\n\n```javascript\nconst sum = (...args) => args.reduce((a, b) => a + b, 0);\n```\n\nArrow functions offer a clearer and more concise way to write functions, especially in cases where handling the `this` context is crucial.",
    "questions": [
      {
        "question": "What is the main advantage of using arrow functions compared to traditional functions?",
        "choices": [
          "More concise syntax and handling of the `this` context",
          "Greater flexibility in the number of arguments",
          "Support for the `arguments` object",
          "Ability to define methods on objects"
        ],
        "correctAnswer": "More concise syntax and handling of the `this` context"
      },
      {
        "question": "How is `this` handled in an arrow function?",
        "choices": [
          "It inherits the `this` from the context where it was defined",
          "It has its own `this` that refers to the function",
          "It is equal to the global `this`",
          "It has no access to `this`"
        ],
        "correctAnswer": "It inherits the `this` from the context where it was defined"
      },
      {
        "question": "How do you define an arrow function with a single parameter?",
        "choices": [
          "You can omit the parentheses around the parameter",
          "You must use parentheses around the parameter",
          "Use a traditional function",
          "The parameter must be an expression"
        ],
        "correctAnswer": "You can omit the parentheses around the parameter"
      },
      {
        "question": "What happens if an arrow function needs to perform multiple operations?",
        "choices": [
          "You should use a code block `{}` and the `return` keyword",
          "The function should be transformed into a traditional function",
          "Operations must be on a single line",
          "An arrow function cannot be used in this case"
        ],
        "correctAnswer": "You should use a code block `{}` and the `return` keyword"
      }
    ],
    "image": "/path/to/image9.jpg",
    "path": "/arrow-functions"
  },
  {
    "id": "9",
    "title": "Closures in JavaScript",
    "content": "A closure in JavaScript is a function that has access to variables from its creation context, even after the outer function has finished executing. Closures allow a function to have 'memory' of the variables from its original context, which is useful for creating functions with private state and for advanced programming techniques.\n\n1. **Defining a Closure**: A closure is created when an inner function accesses variables from its outer function. For example:\n\n```javascript\nfunction outerFunction() {\n  let outerVariable = 'I am outside!';\n  function innerFunction() {\n    console.log(outerVariable);\n  }\n  return innerFunction;\n}\n\nconst myClosure = outerFunction();\nmyClosure(); // I am outside!\n```\n\n2. **Privacy and Encapsulation**: Closures are used to create private variables. Variables in the outer function cannot be accessed directly from outside the function, but the inner function can access them.\n\n```javascript\nfunction createCounter() {\n  let count = 0;\n  return function() {\n    count++;\n    return count;\n  };\n}\n\nconst counter = createCounter();\nconsole.log(counter()); // 1\nconsole.log(counter()); // 2\n```\n\n3. **Closures and Iterators**: Closures can be used to create custom iterators that maintain the state of a series of values.\n\n```javascript\nfunction createRange(start, end) {\n  let current = start;\n  return function() {\n    if (current <= end) return current++;\n    return null;\n  };\n}\n\nconst range = createRange(1, 3);\nconsole.log(range()); // 1\nconsole.log(range()); // 2\nconsole.log(range()); // 3\nconsole.log(range()); // null\n```\n\n4. **Lexical Scope**: Closures are based on lexical scope, meaning that functions remember the environment in which they were created. This is different from dynamic scope, where variables are searched in the calling context of the function.\n\n5. **Using Closures in Callbacks**: Closures are useful in callback functions and events, where they can capture the state of variables at the time the callback is created.\n\n```javascript\nfunction setupButton(buttonId) {\n  let clickCount = 0;\n  document.getElementById(buttonId).addEventListener('click', function() {\n    clickCount++;\n    console.log(`Button clicked ${clickCount} times`);\n  });\n}\n```\n\nClosures provide great flexibility and are a powerful tool for state management and creating more complex functions in JavaScript.",
    "questions": [
      {
        "question": "What is a closure in JavaScript?",
        "choices": [
          "A function that has access to variables from its creation context",
          "A function that does not have access to external variables",
          "A special type of variable",
          "A function that executes immediately"
        ],
        "correctAnswer": "A function that has access to variables from its creation context"
      },
      {
        "question": "How is a closure used to create private variables?",
        "choices": [
          "By encapsulating variables in an outer function and returning an inner function",
          "By declaring variables as `const` within the function",
          "Using the `Object.freeze()` method",
          "Defining variables in a separate module"
        ],
        "correctAnswer": "By encapsulating variables in an outer function and returning an inner function"
      },
      {
        "question": "What is the difference between lexical scope and dynamic scope?",
        "choices": [
          "Lexical scope remembers the environment in which the function was created, while dynamic scope searches for variables in the calling context",
          "Lexical scope searches for variables in the calling context, while dynamic scope remembers the environment in which the function was created",
          "Lexical scope only works with objects, while dynamic scope works with functions",
          "There is no difference between the two scopes"
        ],
        "correctAnswer": "Lexical scope remembers the environment in which the function was created, while dynamic scope searches for variables in the calling context"
      },
      {
        "question": "How can closures be used in callbacks and events?",
        "choices": [
          "By capturing the state of variables at the time the callback is created",
          "By executing functions in a global context",
          "By using the `new` operator to create new instances",
          "By using the `bind()` method to bind the context"
        ],
        "correctAnswer": "By capturing the state of variables at the time the callback is created"
      }
    ],
    "image": "/path/to/image10.jpg",
    "path": "/closures"
  },
  {
    "id": "10",
    "title": "Closures in JavaScript",
    "content": "A closure in JavaScript is a function that has access to variables from its creation context, even after the outer function has finished executing. Closures allow a function to have 'memory' of the variables from its original context, which is useful for creating functions with private state and for advanced programming techniques.\n\n1. **Defining a Closure**: A closure is created when an inner function accesses variables from its outer function. For example:\n\n```javascript\nfunction outerFunction() {\n  let outerVariable = 'I am outside!';\n  function innerFunction() {\n    console.log(outerVariable);\n  }\n  return innerFunction;\n}\n\nconst myClosure = outerFunction();\nmyClosure(); // I am outside!\n```\n\n2. **Privacy and Encapsulation**: Closures are used to create private variables. Variables in the outer function cannot be accessed directly from outside the function, but the inner function can access them.\n\n```javascript\nfunction createCounter() {\n  let count = 0;\n  return function() {\n    count++;\n    return count;\n  };\n}\n\nconst counter = createCounter();\nconsole.log(counter()); // 1\nconsole.log(counter()); // 2\n```\n\n3. **Closures and Iterators**: Closures can be used to create custom iterators that maintain the state of a series of values.\n\n```javascript\nfunction createRange(start, end) {\n  let current = start;\n  return function() {\n    if (current <= end) return current++;\n    return null;\n  };\n}\n\nconst range = createRange(1, 3);\nconsole.log(range()); // 1\nconsole.log(range()); // 2\nconsole.log(range()); // 3\nconsole.log(range()); // null\n```\n\n4. **Lexical Scope**: Closures are based on lexical scope, meaning that functions remember the environment in which they were created. This is different from dynamic scope, where variables are searched in the calling context of the function.\n\n5. **Using Closures in Callbacks**: Closures are useful in callback functions and events, where they can capture the state of variables at the time the callback is created.\n\n```javascript\nfunction setupButton(buttonId) {\n  let clickCount = 0;\n  document.getElementById(buttonId).addEventListener('click', function() {\n    clickCount++;\n    console.log(`Button clicked ${clickCount} times`);\n  });\n}\n```\n\nClosures provide great flexibility and are a powerful tool for state management and creating more complex functions in JavaScript.",
    "questions": [
      {
        "question": "What is a closure in JavaScript?",
        "choices": [
          "A function that has access to variables from its creation context",
          "A function that does not have access to external variables",
          "A special type of variable",
          "A function that executes immediately"
        ],
        "correctAnswer": "A function that has access to variables from its creation context"
      },
      {
        "question": "How is a closure used to create private variables?",
        "choices": [
          "By encapsulating variables in an outer function and returning an inner function",
          "By declaring variables as `const` within the function",
          "Using the `Object.freeze()` method",
          "Defining variables in a separate module"
        ],
        "correctAnswer": "By encapsulating variables in an outer function and returning an inner function"
      },
      {
        "question": "What is the difference between lexical scope and dynamic scope?",
        "choices": [
          "Lexical scope remembers the environment in which the function was created, while dynamic scope searches for variables in the calling context",
          "Lexical scope searches for variables in the calling context, while dynamic scope remembers the environment in which the function was created",
          "Lexical scope only works with objects, while dynamic scope works with functions",
          "There is no difference between the two scopes"
        ],
        "correctAnswer": "Lexical scope remembers the environment in which the function was created, while dynamic scope searches for variables in the calling context"
      },
      {
        "question": "How can closures be used in callbacks and events?",
        "choices": [
          "By capturing the state of variables at the time the callback is created",
          "By executing functions in a global context",
          "By using the `new` operator to create new instances",
          "By using the `bind()` method to bind the context"
        ],
        "correctAnswer": "By capturing the state of variables at the time the callback is created"
      }
    ],
    "image": "/path/to/image10.jpg"
  },
  {
    "id": "11",
    "title": "JavaScript Call Stack",
    "content": "A call stack is a mechanism for an interpreter (like the JavaScript interpreter in a web browser) to keep track of its place in a script that calls multiple functions — what function is currently being run and what functions are called from within that function, etc.\n\nWhen a script calls a function, the interpreter adds it to the call stack and then starts carrying out the function. Any functions that are called by that function are added to the call stack further up and run where their calls are reached. When the current function is finished, the interpreter takes it off the stack and resumes execution where it left off in the last code listing. If the stack takes up more space than it was assigned, a 'stack overflow' error is thrown.\n\n**Example**\n```js\nfunction greeting() {\n  // [1] Some code here\n  sayHi();\n  // [2] Some code here\n}\n\nfunction sayHi() {\n  return 'Hi!';\n}\n\n// Invoke the `greeting` function\ngreeting();\n\n// [3] Some code here\n```\n\nThe call stack will be empty at the very beginning, and the code above would be executed like this:\n\n1. Ignore all functions until it reaches the `greeting()` function invocation.\n2. Add the `greeting()` function to the call stack list, and we have:\n   - `greeting`\n3. Execute all lines of code inside the `greeting()` function.\n4. Get to the `sayHi()` function invocation.\n5. Add the `sayHi()` function to the call stack list, like:\n   - `sayHi`\n   - `greeting`\n6. Execute all lines of code inside the `sayHi()` function until it reaches its end.\n7. Return execution to the line that invoked `sayHi()` and continue executing the rest of the `greeting()` function.\n8. Delete the `sayHi()` function from our call stack list. Now the call stack looks like:\n   - `greeting`\n9. When everything inside the `greeting()` function has been executed, return to its invoking line to continue executing the rest of the JS code.\n10. Delete the `greeting()` function from the call stack list. Once again, the call stack becomes empty.\n\nIn summary, we start with an empty call stack. Whenever we invoke a function, it is automatically added to the call stack. Once the function has executed all of its code, it is automatically removed from the call stack. Ultimately, the stack is empty again.",
    "questions": [
      {
        "question": "What is a call stack in JavaScript?",
        "choices": [
          "A mechanism to keep track of the current function being run and the functions called within it",
          "A type of callback",
          "A method to store variables",
          "A function that runs at the end of a script"
        ],
        "correctAnswer": "A mechanism to keep track of the current function being run and the functions called within it"
      },
      {
        "question": "What happens when a function is called in JavaScript?",
        "choices": [
          "The interpreter ignores it",
          "The interpreter adds it to the call stack and starts executing it",
          "The interpreter throws a stack overflow error",
          "The interpreter deletes it from the call stack"
        ],
        "correctAnswer": "The interpreter adds it to the call stack and starts executing it"
      },
      {
        "question": "What does 'stack overflow' mean?",
        "choices": [
          "The stack has taken up more space than it was assigned",
          "A function has returned successfully",
          "All functions have completed execution",
          "The stack is empty"
        ],
        "correctAnswer": "The stack has taken up more space than it was assigned"
      },
      {
        "question": "What is the initial state of the call stack when a script starts executing?",
        "choices": [
          "Para escribir código limpio y evitar problemas con la visibilidad y la vida útil de las variables",
          "Para utilizar el operador `this` correctamente",
          "Para definir funciones con un solo parámetro",
          "Para trabajar con objetos y arrays"
        ],
        "correctAnswer": "Para escribir código limpio y evitar problemas con la visibilidad y la vida útil de las variables"
      }
    ],
    "image": "/path/to/image11.jpg"
  }
  
  
]
