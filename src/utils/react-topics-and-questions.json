[
  {
   "id": "react-react-1",
    "title": "Imperative vs Declarative Programming",
    "content": "Imperative and declarative programming are two different paradigms used in software development. Imperative programming is a paradigm that focuses on how to achieve a specific task by providing step-by-step instructions to the computer. It emphasizes describing the process and the sequence of commands that change the program's state. Languages like C, Java, and Python often support imperative programming. Examples include loops, conditionals, and explicit control over variables and memory.\n\nDeclarative programming, on the other hand, focuses on what the desired outcome should be rather than how to achieve it. This paradigm allows developers to describe the logic of computation without detailing the control flow. Languages like SQL, HTML, and functional programming languages such as Haskell are declarative. In JavaScript, libraries like React use a declarative style, where you define what the UI should look like based on the application state, rather than manually updating the DOM.\n\nThe main difference between these paradigms lies in their approach: imperative programming tells the computer *how* to do something, while declarative programming tells it *what* to do. Choosing between these paradigms often depends on the specific task and the level of abstraction desired.",
    "questions": [
      {
        "question": "What is the main focus of imperative programming?",
        "choices": [
          "Describing the desired outcome",
          "Providing step-by-step instructions",
          "Managing memory allocation",
          "None of the above"
        ],
        "correctAnswer": "Providing step-by-step instructions"
      },
      {
        "question": "Which programming paradigm focuses on what the desired outcome should be?",
        "choices": [
          "Imperative",
          "Declarative",
          "Procedural",
          "Object-Oriented"
        ],
        "correctAnswer": "Declarative"
      },
      {
        "question": "Which of the following is an example of declarative programming?",
        "choices": [
          "Using loops to iterate over an array",
          "Writing SQL queries",
          "Manually updating the DOM in JavaScript",
          "Using conditionals to control program flow"
        ],
        "correctAnswer": "Writing SQL queries"
      }
    ],
    "image": "/path/to/image2.jpg",
    "path": "/imperative-vs-declarative",
    "next": "/pure-functions"
  },
  {
   "id": "react-react-2",
    "title": "Pure Functions in React",
      "content": "`Pure Functions` are functions that, given the same inputs, will always return the same outputs and have no side effects. In the context of React, pure functions are often used in the creation of functional components and utility functions to ensure predictable and consistent behavior.\n\n### Characteristics of Pure Functions\n\n1. **Deterministic**: A pure function will always return the same result if the inputs are the same.\n2. **No Side Effects**: Pure functions do not modify any external state or interact with the outside world.\n\n### Examples of Pure Functions\n\n- **Example of a Pure Function**:\n\n  ```javascript\n  function add(a, b) {\n    return a + b;\n  }\n  \n  console.log(add(2, 3)); // Output: 5\n  console.log(add(2, 3)); // Output: 5\n  ```\n\n  This `add` function is pure because it always produces the same result for the same inputs and does not modify any external state.\n\n### Pure Functions in React Components\n\nIn React, functional components that do not modify props or manage internal state are considered pure. They only depend on their props and produce consistent output based on those props.\n\n- **Functional Component Example**:\n\n  ```javascript\n  function Greeting({ name }) {\n    return <h1>Hello, {name}!</h1>;\n  }\n  \n  // Usage\n  <Greeting name=\"Alice\" />\n  ```\n\n  The `Greeting` component is pure because it renders output solely based on its props without any side effects.\n\n### Why Use Pure Functions in React?\n\n1. **Predictability**: Pure functions make your components easier to understand and predict since their output depends only on their inputs.\n2. **Testing**: Pure functions are easier to test because you don't need to account for side effects or external state changes.\n3. **Performance**: Reactâ€™s `PureComponent` and `React.memo` use shallow comparison to optimize rendering performance by preventing unnecessary re-renders when component props remain the same.\n\n- **Example with React.memo**:\n\n  ```javascript\n  import React, { memo } from 'react';\n  \n  const PureGreeting = memo(({ name }) => {\n    return <h1>Hello, {name}!</h1>;\n  });\n  \n  // Usage\n  <PureGreeting name=\"Alice\" />\n  ```\n\n  In this example, `PureGreeting` is a pure component optimized with `React.memo` to prevent unnecessary re-renders when props have not changed.\n\n### Summary\n\n- Pure functions are deterministic and have no side effects.\n- They help in creating predictable, testable, and performant React components.\n- React provides tools like `React.memo` and `PureComponent` to optimize components based on pure function principles.",
    "questions": [
      {
        "question": "What defines a pure function in React?",
        "choices": [
          "A function that modifies external state",
          "A function that always returns the same output given the same inputs",
          "A function that triggers side effects",
          "A function that handles asynchronous operations"
        ],
        "correctAnswer": "A function that always returns the same output given the same inputs"
      },
      {
        "question": "Why are pure functions important in React?",
        "choices": [
          "They make components unpredictable",
          "They enhance the performance by preventing unnecessary re-renders",
          "They allow components to modify global state",
          "They cause side effects that affect the DOM"
        ],
        "correctAnswer": "They enhance the performance by preventing unnecessary re-renders"
      },
      {
        "question": "Which of the following is a characteristic of pure functions?",
        "choices": [
          "They can rely on variables outside their scope",
          "They always produce the same output given the same inputs",
          "They can have side effects such as HTTP requests",
          "They modify the component's state directly"
        ],
        "correctAnswer": "They always produce the same output given the same inputs"
      }
    ],
    "image": "/path/to/image3.jpg",
    "path": "/pure-functions",
    "next": "/components"
  },
  {
   "id": "react-react-3",
    "title": "Components in React",
    "content": "`Components` are the building blocks of a React application. They allow you to split the UI into independent, reusable pieces that can be managed separately. Components can be either class-based or functional, and they can accept inputs called `props` and manage their own internal state.\n\n### Functional Components\n\nFunctional components are simpler and are typically used for components that do not have their own state or lifecycle methods.\n\n- **Example**:\n\n  ```javascript\n  function Welcome(props) {\n    return <h1>Hello, {props.name}</h1>;\n  }\n  \n  // Usage\n  <Welcome name=\"Alice\" />\n  ```\n\n### Class Components\n\nClass components are more powerful and can hold and manage their own state. They also provide access to lifecycle methods.\n\n- **Example**:\n\n  ```javascript\n  class Welcome extends React.Component {\n    render() {\n      return <h1>Hello, {this.props.name}</h1>;\n    }\n  }\n  \n  // Usage\n  <Welcome name=\"Alice\" />\n  ```\n\n### Props\n\n`Props` (short for properties) are read-only values passed from a parent component to a child component. They allow you to customize the behavior or appearance of a component.\n\n- **Example**:\n\n  ```javascript\n  function Greeting(props) {\n    return <p>Welcome, {props.userName}!</p>;\n  }\n  \n  // Usage\n  <Greeting userName=\"Bob\" />\n  ```\n\n### State\n\n`State` is an internal data store for a component that can be changed by the component itself. State is used in class components with `this.setState` and in functional components with the `useState` hook.\n\n- **Class Component Example**:\n\n  ```javascript\n  class Counter extends React.Component {\n    constructor(props) {\n      super(props);\n      this.state = { count: 0 };\n    }\n    \n    increment = () => {\n      this.setState({ count: this.state.count + 1 });\n    }\n    \n    render() {\n      return (\n        <div>\n          <p>Count: {this.state.count}</p>\n          <button onClick={this.increment}>Increment</button>\n        </div>\n      );\n    }\n  }\n  ```\n\n- **Functional Component Example**:\n\n  ```javascript\n  import React, { useState } from 'react';\n  \n  function Counter() {\n    const [count, setCount] = useState(0);\n    \n    return (\n      <div>\n        <p>Count: {count}</p>\n        <button onClick={() => setCount(count + 1)}>Increment</button>\n      </div>\n    );\n  }\n  ```\n\n### Component Lifecycle\n\nClass components have lifecycle methods that allow you to run code at specific points in a component's life. For functional components, hooks like `useEffect` can be used to handle side effects and lifecycle events.\n\n### Summary\n\n- Components are the core building blocks of a React application.\n- They can be functional or class-based.\n- Props allow you to pass data to components, while state is used for internal data management.\n- Lifecycle methods (class components) and hooks (functional components) manage side effects and other component-specific logic.\n\nUnderstanding how to use and manage components is crucial for building complex and maintainable React applications.",
    "questions": [
      {
        "question": "What are React components?",
        "choices": [
          "Reusable pieces of UI in a React application",
          "JavaScript variables",
          "HTML elements",
          "Global state management tools"
        ],
        "correctAnswer": "Reusable pieces of UI in a React application"
      },
      {
        "question": "What is the difference between functional and class components in React?",
        "choices": [
          "Functional components are written as functions and class components as ES6 classes",
          "Class components cannot manage state",
          "Functional components are faster than class components",
          "There is no difference between them"
        ],
        "correctAnswer": "Functional components are written as functions and class components as ES6 classes"
      },
      {
        "question": "How do React components communicate with each other?",
        "choices": [
          "Through global variables",
          "By passing data down from parent to child components via props",
          "By modifying each other's state directly",
          "Using React Hooks"
        ],
        "correctAnswer": "By passing data down from parent to child components via props"
      }
    ],
    "image": "/path/to/image4.jpg",
    "path": "/components",
    "next": "/jsx"
  },
  {
  "id": "react-react-4",
    "title": "JSX in React",
    "content": "`JSX` (JavaScript XML) is a syntax extension for JavaScript commonly used with React. It allows you to write HTML elements and components within JavaScript code, making it easier to create and manage UI components.\n\n### Basics of JSX\n\nJSX allows you to write elements that look like HTML but are actually JavaScript objects. Each JSX element is converted into a React element by Babel during the build process.\n\n- **Example**:\n\n  ```javascript\n  const element = <h1>Hello, world!</h1>;\n  ```\n\n- **Rendering JSX**: To render JSX, you use `ReactDOM.render` to attach it to a DOM element.\n\n  ```javascript\n  import React from 'react';\n  import ReactDOM from 'react-dom';\n\n  const element = <h1>Hello, world!</h1>;\n  ReactDOM.render(element, document.getElementById('root'));\n  ```\n\n### Embedding Expressions\n\nJSX allows you to embed JavaScript expressions inside curly braces `{}`.\n\n- **Example**:\n\n  ```javascript\n  const name = 'Alice';\n  const element = <h1>Hello, {name}!</h1>;\n  ```\n\n### JSX Attributes\n\nJSX attributes are similar to HTML attributes but with some differences.\n\n- **Example**:\n\n  ```javascript\n  const element = <input type=\"text\" value=\"Hello\" />;\n  ```\n\n- **Dynamic Attributes**: You can use expressions to set attributes dynamically.\n\n  ```javascript\n  const isChecked = true;\n  const element = <input type=\"checkbox\" checked={isChecked} />;\n  ```\n\n### JSX and Components\n\nJSX is often used to define components. Components can be either functional or class-based.\n\n- **Functional Component Example**:\n\n  ```javascript\n  function Welcome(props) {\n    return <h1>Hello, {props.name}</h1>;\n  }\n  ```\n\n- **Class Component Example**:\n\n  ```javascript\n  class Welcome extends React.Component {\n    render() {\n      return <h1>Hello, {this.props.name}</h1>;\n    }\n  }\n  ```\n\n### JSX Best Practices\n\n- **Use CamelCase for Component Names**: Component names should start with a capital letter.\n- **Self-Closing Tags**: Use self-closing tags for elements that do not have children, like `<img />` or `<input />`.\n- **Avoid Inline Styles**: Prefer using CSS classes over inline styles for better maintainability.\n\n### Summary\n\n- JSX allows you to write HTML-like code within JavaScript.\n- It is transpiled into React elements and rendered by React.\n- JSX supports embedding expressions, using dynamic attributes, and defining components.\n- Following best practices ensures clean and maintainable code.\n\nJSX makes the process of building React components more intuitive and easier to read, combining the flexibility of JavaScript with the structure of HTML.",
    "questions": [
      {
        "question": "What does JSX stand for?",
        "choices": [
          "JavaScript XML",
          "JavaScript Extension",
          "Java Syntax Extension",
          "JavaScript Extra"
        ],
        "correctAnswer": "JavaScript XML"
      },
      {
        "question": "Is JSX required to write React applications?",
        "choices": [
          "Yes, it is mandatory",
          "No, but it is recommended because it simplifies writing React components",
          "Yes, because React only works with JSX",
          "No, React does not support JSX"
        ],
        "correctAnswer": "No, but it is recommended because it simplifies writing React components"
      },
      {
        "question": "How do you include JavaScript expressions in JSX?",
        "choices": [
          "Using double curly braces `{{}}`",
          "By embedding them within single quotes `''`",
          "By enclosing them in curly braces `{}`",
          "By writing them directly in HTML tags"
        ],
        "correctAnswer": "By enclosing them in curly braces `{}`"
      }
    ],
    "image": "/path/to/image5.jpg",
    "path": "/jsx",
    "next": "/props-and-state"
  },
  {
  "id": "react-react-5",
    "title": "Props and State in React",
    "content": "`Props` and `state` are fundamental concepts in React that help manage and control data within components.\n\n### Props\n\n**Props** (short for properties) are used to pass data from a parent component to a child component. They are read-only and cannot be modified by the child component.\n\n- **Defining Props**: You define props when you use a component by specifying attributes.\n\n  ```javascript\n  <Greeting name=\"Alice\" />\n  ```\n\n- **Using Props**: Inside the child component, you access props through the `props` object or by destructuring.\n\n  ```javascript\n  function Greeting(props) {\n    return <h1>Hello, {props.name}!</h1>;\n  }\n  \n  // Using destructuring\n  function Greeting({ name }) {\n    return <h1>Hello, {name}!</h1>;\n  }\n  ```\n\n### State\n\n**State** is used to manage data that can change over time within a component. Unlike props, state is mutable and can be updated by the component that owns it.\n\n- **Defining State**: You define state using the `useState` hook in functional components or by initializing it in the `constructor` of class components.\n\n  ```javascript\n  // Functional Component\n  import React, { useState } from 'react';\n\n  function Counter() {\n    const [count, setCount] = useState(0);\n    return (\n      <div>\n        <p>You clicked {count} times</p>\n        <button onClick={() => setCount(count + 1)}>Click me</button>\n      </div>\n    );\n  }\n  \n  // Class Component\n  class Counter extends React.Component {\n    constructor(props) {\n      super(props);\n      this.state = { count: 0 };\n    }\n    render() {\n      return (\n        <div>\n          <p>You clicked {this.state.count} times</p>\n          <button onClick={() => this.setState({ count: this.state.count + 1 })}>Click me</button>\n        </div>\n      );\n    }\n  }\n  ```\n\n### Summary\n\n- **Props** are used to pass data from parent to child components and are read-only.\n- **State** is used to manage and update data within a component and is mutable.\n- Props are passed into components via attributes, while state is managed within the component itself.\n- Changing state can trigger a re-render, while props are managed by the parent component.\n\nUnderstanding the difference between props and state helps you manage data flow and component behavior effectively in React.",
    "questions": [
      {
        "question": "What are props in React?",
        "choices": [
          "A way to store internal data",
          "A method to pass data from one component to another",
          "A function to update the component's state",
          "A React hook"
        ],
        "correctAnswer": "A method to pass data from one component to another"
      },
      {
        "question": "Can a component modify its props?",
        "choices": [
          "Yes, using the setProps method",
          "No, props are read-only",
          "Yes, by updating the state",
          "No, props can only be passed from parent to child"
        ],
        "correctAnswer": "No, props are read-only"
      },
      {
        "question": "How do you update a component's state in React?",
        "choices": [
          "By directly modifying the state object",
          "Using the `useEffect` hook",
          "Using the `setState` function or `useState` hook",
          "By passing new props"
        ],
        "correctAnswer": "Using the `setState` function or `useState` hook"
      }
    ],
    "image": "/path/to/image6.jpg",
    "path": "/props-and-state",
    "next": "/lifecycle-methods"
  },
  {
   "id": "react-6",
    "title": "Lifecycle Methods in React",
    "content": "`Lifecycle methods` in React class components are special methods that allow you to hook into different phases of a component's lifecycle. These methods enable you to run code at specific points during the component's creation, update, and unmounting phases. Hereâ€™s a summary of key lifecycle methods and their uses:\n\n### Mounting\n\n**Mounting** refers to the phase when a component is being created and inserted into the DOM.\n\n- **`constructor(props)`**: The constructor is called before the component is mounted. It is used to initialize state and bind event handlers.\n\n  ```javascript\n  constructor(props) {\n    super(props);\n    this.state = { count: 0 };\n  }\n  ```\n\n- **`componentDidMount()`**: This method is called immediately after the component is mounted. It's a good place for fetching data or interacting with the DOM.\n\n  ```javascript\n  componentDidMount() {\n    console.log('Component mounted!');\n    // Fetch data or setup subscriptions\n  }\n  ```\n\n### Updating\n\n**Updating** refers to the phase when a component's state or props change, causing it to re-render.\n\n- **`shouldComponentUpdate(nextProps, nextState)`**: This method allows you to control whether a component should re-render. It returns `true` (default) or `false` based on the comparison of current and next props/state.\n\n  ```javascript\n  shouldComponentUpdate(nextProps, nextState) {\n    return nextState.count !== this.state.count;\n  }\n  ```\n\n- **`componentDidUpdate(prevProps, prevState)`**: This method is called after the component has updated. It is useful for performing operations based on changes in props or state.\n\n  ```javascript\n  componentDidUpdate(prevProps, prevState) {\n    if (prevState.count !== this.state.count) {\n      console.log('Count updated!');\n    }\n  }\n  ```\n\n### Unmounting\n\n**Unmounting** refers to the phase when a component is being removed from the DOM.\n\n- **`componentWillUnmount()`**: This method is called just before a component is unmounted and destroyed. It is useful for cleanup tasks like canceling subscriptions or timers.\n\n  ```javascript\n  componentWillUnmount() {\n    console.log('Component will unmount!');\n    // Cleanup subscriptions or timers\n  }\n  ```\n\n### Error Handling\n\n- **`componentDidCatch(error, info)`**: This method is called when an error is thrown during rendering or in lifecycle methods. It allows you to handle errors and display a fallback UI.\n\n  ```javascript\n  componentDidCatch(error, info) {\n    console.log('Error occurred:', error);\n    // Handle the error and update state or log the error\n  }\n  ```\n\n### Summary\n\n- **Mounting**: `constructor`, `componentDidMount`\n- **Updating**: `shouldComponentUpdate`, `componentDidUpdate`\n- **Unmounting**: `componentWillUnmount`\n- **Error Handling**: `componentDidCatch`\n\nUnderstanding lifecycle methods is crucial for managing component behavior and optimizing performance in React class components. In functional components, similar effects can be achieved using the `useEffect` hook.",
    "questions": [
      {
        "question": "Which lifecycle method is called when a component is first added to the DOM?",
        "choices": [
          "componentDidMount",
          "componentDidUpdate",
          "componentWillUnmount",
          "constructor"
        ],
        "correctAnswer": "componentDidMount"
      },
      {
        "question": "What is the purpose of the `componentWillUnmount` lifecycle method?",
        "choices": [
          "To fetch data after the component is mounted",
          "To update the component's state",
          "To perform cleanup before the component is removed from the DOM",
          "To render the component"
        ],
        "correctAnswer": "To perform cleanup before the component is removed from the DOM"
      },
      {
        "question": "How can you mimic `componentDidUpdate` behavior in a functional component?",
        "choices": [
          "Using `useState`",
          "Using `useEffect` with dependencies",
          "Using `componentDidMount`",
          "Using `useRef`"
        ],
        "correctAnswer": "Using `useEffect` with dependencies"
      }
    ],
    "image": "/path/to/image7.jpg",
    "path": "/lifecycle-methods",
    "next": "/handling-events"
  },
  {
   "id": "react-7",
    "title": "Handling Events in React",
    "content": "`Handling Events` in React is similar to handling events in regular HTML, but with some differences in syntax and behavior. React uses a synthetic event system to handle events in a cross-browser-compatible way.\n\n### Basic Event Handling\n\nIn React, you attach event handlers directly to JSX elements. The event handlers are written in camelCase syntax and are passed as props.\n\n#### Example: Handling a Click Event\n\nHere's a basic example of handling a button click event:\n\n```javascript\nimport React from 'react';\n\nconst ClickCounter = () => {\n  const handleClick = () => {\n    alert('Button was clicked!');\n  };\n\n  return (\n    <button onClick={handleClick}>Click me</button>\n  );\n};\n```\n\n### Event Handler Methods\n\nYou can define event handlers as methods in a class component or as functions in a functional component. Both approaches are valid.\n\n#### Class Component Example\n\n```javascript\nimport React, { Component } from 'react';\n\nclass MyForm extends Component {\n  handleSubmit = (event) => {\n    event.preventDefault();\n    alert('Form submitted!');\n  };\n\n  render() {\n    return (\n      <form onSubmit={this.handleSubmit}>\n        <button type=\"submit\">Submit</button>\n      </form>\n    );\n  }\n}\n```\n\n#### Functional Component Example\n\n```javascript\nimport React from 'react';\n\nconst MyForm = () => {\n  const handleSubmit = (event) => {\n    event.preventDefault();\n    alert('Form submitted!');\n  };\n\n  return (\n    <form onSubmit={handleSubmit}>\n      <button type=\"submit\">Submit</button>\n    </form>\n  );\n};\n```\n\n### Passing Arguments to Event Handlers\n\nIf you need to pass additional arguments to your event handlers, you can use an arrow function or `bind` method.\n\n#### Example: Passing Arguments\n\n```javascript\nimport React from 'react';\n\nconst Greeting = ({ name }) => {\n  const handleClick = (message) => {\n    alert(message);\n  };\n\n  return (\n    <button onClick={() => handleClick(`Hello, ${name}!`)}>Greet</button>\n  );\n};\n```\n\n### Event Object\n\nEvent handlers receive a synthetic event object that contains information about the event. This object is similar to the native event object in the browser.\n\n#### Example: Accessing Event Object\n\n```javascript\nimport React from 'react';\n\nconst MousePosition = () => {\n  const handleMouseMove = (event) => {\n    console.log('Mouse position:', event.clientX, event.clientY);\n  };\n\n  return (\n    <div onMouseMove={handleMouseMove} style={{ height: '100vh' }}>\n      Move your mouse around!\n    </div>\n  );\n};\n```\n\n### Summary\n\n- Use camelCase syntax for event handlers in JSX.\n- Event handlers can be defined as methods in class components or functions in functional components.\n- You can pass arguments to event handlers using arrow functions or `bind`.\n- Access the event object to get information about the event and its properties.\n- React's synthetic event system ensures compatibility across different browsers.",
    "questions": [
      {
        "question": "How do you handle a click event in a React component?",
        "choices": [
          "By adding an `onclick` attribute to the element",
          "By passing an `onClick` prop to the element",
          "By using a `click` function",
          "By calling `addEventListener`"
        ],
        "correctAnswer": "By passing an `onClick` prop to the element"
      },
      {
        "question": "What is the purpose of `event.preventDefault()` in an event handler?",
        "choices": [
          "To stop the event from bubbling up the DOM tree",
          "To cancel the default action of the event",
          "To log the event to the console",
          "To remove the event listener"
        ],
        "correctAnswer": "To cancel the default action of the event"
      },
      {
        "question": "Why is it important to bind event handlers in React class components?",
        "choices": [
          "To make the handler asynchronous",
          "To ensure that `this` refers to the correct context",
          "To optimize performance",
          "To prevent memory leaks"
        ],
        "correctAnswer": "To ensure that `this` refers to the correct context"
      }
    ],
    "image": "/path/to/image8.jpg",
    "path": "/handling-events",
    "next": "/conditional-rendering"
  },
  {
   "id": "react-8",
    "title": "Conditional Rendering in React",
    "content": "`Conditional Rendering` in React allows you to display different UI elements based on certain conditions. This is essential for creating dynamic and interactive applications where the displayed content needs to change based on user interactions or state changes.\n\n### Basic Conditional Rendering\n\nYou can use JavaScript operators like `if`, `ternary operator`, or `&&` (logical AND) for conditional rendering in React.\n\n#### Using `if` Statements\n\nYou can use `if` statements inside a functional component to conditionally render elements:\n\n```javascript\nimport React from 'react';\n\nconst Greeting = ({ isLoggedIn }) => {\n  if (isLoggedIn) {\n    return <h1>Welcome back!</h1>;\n  } else {\n    return <h1>Please sign up.</h1>;\n  }\n};\n```\n\n#### Using the Ternary Operator\n\nThe ternary operator is a concise way to handle conditional rendering:\n\n```javascript\nimport React from 'react';\n\nconst Greeting = ({ isLoggedIn }) => (\n  <h1>{isLoggedIn ? 'Welcome back!' : 'Please sign up.'}</h1>\n);\n```\n\n#### Using Logical AND (`&&`)\n\nYou can use the logical AND operator to render elements conditionally:\n\n```javascript\nimport React from 'react';\n\nconst Notification = ({ unreadMessages }) => (\n  <div>\n    {unreadMessages.length > 0 && <h2>You have {unreadMessages.length} unread messages.</h2>}\n  </div>\n);\n```\n\n### Conditional Rendering with Elements\n\nYou can also render different elements conditionally:\n\n```javascript\nimport React from 'react';\n\nconst UserProfile = ({ user }) => {\n  let content;\n  if (user) {\n    content = <div>Welcome, {user.name}!</div>;\n  } else {\n    content = <div>Please log in.</div>;\n  }\n  return <div>{content}</div>;\n};\n```\n\n### Conditional Rendering with Components\n\nYou can conditionally render components based on state or props:\n\n```javascript\nimport React, { useState } from 'react';\n\nconst Dashboard = () => {\n  const [isAdmin, setIsAdmin] = useState(false);\n\n  return (\n    <div>\n      {isAdmin ? <AdminPanel /> : <UserPanel />}\n    </div>\n  );\n};\n\nconst AdminPanel = () => <div>Admin Panel</div>;\nconst UserPanel = () => <div>User Panel</div>;\n```\n\n### Summary\n\n- Use JavaScript operators like `if`, `ternary operator`, or `&&` for conditional rendering.\n- Conditional rendering allows you to dynamically display different UI elements based on state or props.\n- It helps create interactive and responsive user interfaces by changing what the user sees based on their interactions or application state.",
    "questions": [
      {
        "question": "What is a common method for conditional rendering in React?",
        "choices": [
          "Using `if-else` statements in JSX",
          "Using the ternary operator",
          "Using a `for` loop",
          "Using `switch` statements in JSX"
        ],
        "correctAnswer": "Using the ternary operator"
      },
      {
        "question": "Which operator can you use to conditionally render an element only if a condition is true?",
        "choices": [
          "|| (OR)",
          "?? (Nullish Coalescing)",
          "&& (AND)",
          "! (NOT)"
        ],
        "correctAnswer": "&& (AND)"
      },
      {
        "question": "Can you use `if` statements directly inside JSX?",
        "choices": [
          "Yes, but only with certain conditions",
          "No, `if` statements cannot be used in JSX",
          "Yes, `if` statements can be used directly in JSX",
          "No, only ternary operators can be used"
        ],
        "correctAnswer": "No, `if` statements cannot be used in JSX"
      }
    ],
    "image": "/path/to/image9.jpg",
    "path": "/conditional-rendering",
    "next": "/lists-and-keys"
  },
  {
   "id": "react-9",
    "title": "Lists and Keys in React",
    "content": "`Lists` and `Keys` are essential concepts in React for rendering collections of items efficiently and effectively. When rendering a list of items, React uses `keys` to identify which items have changed, been added, or removed.\n\n### Rendering Lists\n\nIn React, you can render lists of elements using the `map` function. Each item in the list should be mapped to a React element. Here's a basic example:\n\n```javascript\nimport React from 'react';\n\nconst items = ['Apple', 'Banana', 'Cherry'];\n\nconst FruitList = () => {\n  return (\n    <ul>\n      {items.map((item, index) => (\n        <li key={index}>{item}</li>\n      ))}\n    </ul>\n  );\n};\n```\n\n### Keys\n\n`Keys` help React identify which items have changed, been added, or removed. Keys should be unique among siblings and stable (i.e., they should not change between renders). It is recommended to use unique identifiers from your data, if available.\n\n#### Example with Unique Keys\n\nInstead of using the `index` as a key, use a unique identifier from your data if available:\n\n```javascript\nimport React from 'react';\n\nconst items = [\n  { id: 1, name: 'Apple' },\n  { id: 2, name: 'Banana' },\n  { id: 3, name: 'Cherry' }\n];\n\nconst FruitList = () => {\n  return (\n    <ul>\n      {items.map(item => (\n        <li key={item.id}>{item.name}</li>\n      ))}\n    </ul>\n  );\n};\n```\n\n### Why Keys Are Important\n\nKeys help React optimize the rendering of lists by allowing it to track each element's identity. This helps React update only the items that have changed rather than re-rendering the entire list. Properly using keys improves performance and ensures that your list behaves consistently.\n\n### Common Pitfalls\n\n- **Using Array Indexes**: While using array indexes as keys is a common practice, it can lead to issues if the list changes over time (e.g., items are added or removed). It's best to use unique and stable values whenever possible.\n- **Non-Unique Keys**: Avoid using non-unique keys as they can lead to incorrect behavior and rendering issues.\n\n### Summary\n\n- Use the `map` function to render lists of elements.\n- Always provide a unique and stable `key` prop to each list item.\n- Avoid using array indexes as keys if the list is dynamic and may change.",
    "questions": [
      {
        "question": "Why are keys important when rendering lists in React?",
        "choices": [
          "They make the list look nicer",
          "They help React identify which items have changed, been added, or removed",
          "They add styling to list items",
          "They make the list more readable"
        ],
        "correctAnswer": "They help React identify which items have changed, been added, or removed"
      },
      {
        "question": "What should you generally avoid using as a key in a list?",
        "choices": [
          "A unique identifier from your data",
          "An array index",
          "A random number",
          "A string value from your data"
        ],
        "correctAnswer": "An array index"
      },
      {
        "question": "What does React do when you don't provide keys for list items?",
        "choices": [
          "Ignores the list",
          "Throws an error",
          "Re-renders the entire list every time",
          "Applies a default key"
        ],
        "correctAnswer": "Re-renders the entire list every time"
      }
    ],
    "image": "/path/to/image10.jpg",
    "path": "/lists-and-keys",
    "next": "/forms"
  },
  {
   "id": "react-10",
    "title": "Forms in React",
    "content": "`Forms` in React are used to collect user input and handle form submissions. React provides a way to manage form state and validation using controlled components, which keep form data in sync with the component state.\n\n### Controlled Components\n\nIn React, controlled components are form elements whose values are controlled by React state. This means the form data is managed by the component's state rather than the DOM.\n\n#### Basic Example\n\n```javascript\nimport React, { useState } from 'react';\n\nconst MyForm = () => {\n  const [inputValue, setInputValue] = useState('');\n\n  const handleChange = (event) => {\n    setInputValue(event.target.value);\n  };\n\n  const handleSubmit = (event) => {\n    event.preventDefault();\n    alert(`A name was submitted: ${inputValue}`);\n  };\n\n  return (\n    <form onSubmit={handleSubmit}>\n      <label>\n        Name:\n        <input type=\"text\" value={inputValue} onChange={handleChange} />\n      </label>\n      <button type=\"submit\">Submit</button>\n    </form>\n  );\n};\n```\n\n### Handling Multiple Inputs\n\nWhen managing multiple inputs, you can use the `name` attribute to identify which field is being updated. This approach helps keep your code organized and avoids the need for multiple `useState` calls.\n\n```javascript\nimport React, { useState } from 'react';\n\nconst MultiInputForm = () => {\n  const [form, setForm] = useState({ name: '', email: '' });\n\n  const handleChange = (event) => {\n    const { name, value } = event.target;\n    setForm({ ...form, [name]: value });\n  };\n\n  const handleSubmit = (event) => {\n    event.preventDefault();\n    alert(`Name: ${form.name}, Email: ${form.email}`);\n  };\n\n  return (\n    <form onSubmit={handleSubmit}>\n      <label>\n        Name:\n        <input type=\"text\" name=\"name\" value={form.name} onChange={handleChange} />\n      </label>\n      <br />\n      <label>\n        Email:\n        <input type=\"email\" name=\"email\" value={form.email} onChange={handleChange} />\n      </label>\n      <br />\n      <button type=\"submit\">Submit</button>\n    </form>\n  );\n};\n```\n\n### Validation\n\nYou can perform validation in the `handleSubmit` function or use libraries like `Formik` or `React Hook Form` for more complex validation logic.\n\n#### Simple Validation Example\n\n```javascript\nimport React, { useState } from 'react';\n\nconst ValidatedForm = () => {\n  const [inputValue, setInputValue] = useState('');\n  const [error, setError] = useState('');\n\n  const handleChange = (event) => {\n    setInputValue(event.target.value);\n  };\n\n  const handleSubmit = (event) => {\n    event.preventDefault();\n    if (!inputValue) {\n      setError('Name is required');\n    } else {\n      setError('');\n      alert(`A name was submitted: ${inputValue}`);\n    }\n  };\n\n  return (\n    <form onSubmit={handleSubmit}>\n      <label>\n        Name:\n        <input type=\"text\" value={inputValue} onChange={handleChange} />\n      </label>\n      <button type=\"submit\">Submit</button>\n      {error && <p style={{ color: 'red' }}>{error}</p>}\n    </form>\n  );\n};\n```\n\n### Summary\n\n- Controlled components keep form data in sync with component state.\n- Use the `name` attribute to manage multiple inputs in a single state object.\n- Perform validation in the `handleSubmit` function or use validation libraries for more advanced scenarios.",
    "questions": [
      {
        "question": "What are controlled components in React?",
        "choices": [
          "Components that control the appearance of a form",
          "Form elements where the value is controlled by the component's state",
          "Forms that use native HTML elements",
          "Form elements that are controlled by the DOM"
        ],
        "correctAnswer": "Form elements where the value is controlled by the component's state"
      },
      {
        "question": "Why are controlled components preferred in React?",
        "choices": [
          "They are easier to style",
          "They allow for a single source of truth for form data",
          "They require less code",
          "They do not require event handlers"
        ],
        "correctAnswer": "They allow for a single source of truth for form data"
      },
      {
        "question": "What is the main difference between controlled and uncontrolled components in React?",
        "choices": [
          "Controlled components are controlled by React state, while uncontrolled components are controlled by the DOM",
          "Controlled components are more performant",
          "Uncontrolled components are easier to manage",
          "There is no difference"
        ],
        "correctAnswer": "Controlled components are controlled by React state, while uncontrolled components are controlled by the DOM"
      }
    ],
    "image": "/path/to/image11.jpg",
    "path": "/forms",
    "next": "/handling-events"
  },
  {
   "id": "react-11",
    "title": "useState in React",
    "content": "`useState` is a React hook that allows you to add state to functional components. State in React is a way to store and manage data that changes over time, affecting how the component renders.\n\n### Basic Usage\n\n`useState` takes the initial state as an argument and returns an array with two elements: the current state and a function to update it.\n\n```javascript\nimport React, { useState } from 'react';\n\nconst Counter = () => {\n  const [count, setCount] = useState(0); // Initial state is 0\n\n  return (\n    <div>\n      <p>You clicked {count} times</p>\n      <button onClick={() => setCount(count + 1)}>Click me</button>\n    </div>\n  );\n};\n```\n\n### Updating State\n\nTo update the state, call the state updater function with the new value. If the new state depends on the previous state, use a function to update it.\n\n```javascript\nimport React, { useState } from 'react';\n\nconst CounterWithFunction = () => {\n  const [count, setCount] = useState(0);\n\n  const increment = () => {\n    setCount(prevCount => prevCount + 1); // Update state based on previous state\n  };\n\n  return (\n    <div>\n      <p>You clicked {count} times</p>\n      <button onClick={increment}>Click me</button>\n    </div>\n  );\n};\n```\n\n### State with Objects\n\nWhen using state with objects, you need to ensure you spread the previous state to avoid overwriting other properties.\n\n```javascript\nimport React, { useState } from 'react';\n\nconst Form = () => {\n  const [form, setForm] = useState({ name: '', email: '' });\n\n  const handleChange = (e) => {\n    const { name, value } = e.target;\n    setForm(prevForm => ({ ...prevForm, [name]: value }));\n  };\n\n  return (\n    <form>\n      <label>\n        Name:\n        <input type=\"text\" name=\"name\" value={form.name} onChange={handleChange} />\n      </label>\n      <br />\n      <label>\n        Email:\n        <input type=\"email\" name=\"email\" value={form.email} onChange={handleChange} />\n      </label>\n    </form>\n  );\n};\n```\n\n### Summary\n\n- `useState` is used to add state to functional components, allowing them to manage and update data.\n- Call the updater function to modify the state, and use a function form to ensure updates based on previous state.\n- Handle state with objects carefully by spreading previous state to avoid overwriting existing data.",
    "questions": [
      {
        "question": "What does the `useState` hook in React allow you to do?",
        "choices": [
          "Add styles to a component",
          "Add state to functional components",
          "Handle side effects",
          "Manage component lifecycle"
        ],
        "correctAnswer": "Add state to functional components"
      },
      {
        "question": "What does `useState` return?",
        "choices": [
          "An object with state properties",
          "A function to render the component",
          "An array containing the current state and a function to update it",
          "A boolean indicating if the component should update"
        ],
        "correctAnswer": "An array containing the current state and a function to update it"
      },
      {
        "question": "How do you update the state when using `useState`?",
        "choices": [
          "By directly assigning a new value to the state variable",
          "By calling the update function returned by `useState`",
          "By using the `setState` method",
          "By re-rendering the component"
        ],
        "correctAnswer": "By calling the update function returned by `useState`"
      }
    ],
    "image": "/path/to/image9.jpg",
    "path": "/useState",
    "next": "/useEffect"
  },
  {
   "id": "react-12",
    "title": "useEffect in React",
    "content": "`useEffect` is a React hook that manages side effects in functional components. Side effects are operations that can affect other components or outside systems, such as data fetching, subscriptions, or manually changing the DOM.\n\n### Basic Usage\n\n`useEffect` takes two arguments: a function containing the side effect logic and an optional dependency array. The effect function runs after the component renders. If the dependency array is provided, the effect runs only when the values in the array change.\n\n```javascript\nimport React, { useEffect, useState } from 'react';\n\nconst FetchDataComponent = () => {\n  const [data, setData] = useState(null);\n  const [loading, setLoading] = useState(true);\n\n  useEffect(() => {\n    const fetchData = async () => {\n      const response = await fetch('https://api.example.com/data');\n      const result = await response.json();\n      setData(result);\n      setLoading(false);\n    };\n\n    fetchData();\n  }, []); // Empty dependency array means this runs once, similar to componentDidMount\n\n  if (loading) return <p>Loading...</p>;\n  return <div>Data: {JSON.stringify(data)}</div>;\n};\n```\n\n### Cleanup Effects\n\n`useEffect` can also return a cleanup function that React calls when the component unmounts or before running the effect again. This is useful for cleaning up subscriptions or timers.\n\n```javascript\nimport React, { useEffect, useState } from 'react';\n\nconst TimerComponent = () => {\n  const [time, setTime] = useState(new Date().toLocaleTimeString());\n\n  useEffect(() => {\n    const timer = setInterval(() => {\n      setTime(new Date().toLocaleTimeString());\n    }, 1000);\n\n    // Cleanup function\n    return () => clearInterval(timer);\n  }, []); // Empty dependency array means this effect runs once\n\n  return <div>Current Time: {time}</div>;\n};\n```\n\n### Dependencies\n\nIf you include a dependency array, `useEffect` runs the effect function whenever one of the dependencies changes. This is useful for reacting to changes in props or state.\n\n```javascript\nimport React, { useEffect, useState } from 'react';\n\nconst ComponentWithDependencies = ({ value }) => {\n  const [data, setData] = useState(null);\n\n  useEffect(() => {\n    console.log('Value changed:', value);\n    // Perform side effect here\n  }, [value]); // Dependency array includes 'value'\n\n  return <div>Value: {value}</div>;\n};\n```\n\n### Summary\n\n- `useEffect` handles side effects in functional components, replacing lifecycle methods like `componentDidMount`, `componentDidUpdate`, and `componentWillUnmount`.\n- Use `useEffect` to perform operations like data fetching, subscriptions, or DOM manipulations.\n- Include a dependency array to control when the effect runs and use a cleanup function for clean-up operations.",
    "questions": [
      {
        "question": "What is the primary purpose of the `useEffect` hook in React?",
        "choices": [
          "To manage state in functional components",
          "To handle side effects in function components",
          "To create reusable components",
          "To render JSX elements"
        ],
        "correctAnswer": "To handle side effects in function components"
      },
      {
        "question": "What does the dependency array in `useEffect` do?",
        "choices": [
          "Determines how many times the effect should run",
          "Specifies when the effect should run based on the values in the array",
          "Holds the initial state values",
          "Indicates if the effect should run before rendering"
        ],
        "correctAnswer": "Specifies when the effect should run based on the values in the array"
      },
      {
        "question": "How can you clean up resources in `useEffect`?",
        "choices": [
          "By returning a cleanup function from the effect",
          "By using the `cleanupEffect` hook",
          "By setting the state to `null`",
          "By calling `unmountEffect`"
        ],
        "correctAnswer": "By returning a cleanup function from the effect"
      }
    ],
    "image": "/path/to/image10.jpg",
    "path": "/useEffect",
    "next": "/useMemo"
  },
  {
   "id": "react-13",
    "title": "useMemo in React",
    "content": "`useMemo` is a React hook that helps optimize performance by memoizing the result of a computation. It returns a memoized value that only changes if one of the dependencies has changed. This can prevent expensive calculations from running on every render, thereby improving performance.\n\n### Basic Usage\n\nTo use `useMemo`, pass a function that performs a computation and a dependency array. The computed value will only be recalculated if one of the dependencies changes.\n\n```javascript\nimport React, { useMemo, useState } from 'react';\n\nconst ExpensiveComponent = ({ num }) => {\n  const computeExpensiveValue = (n) => {\n    console.log('Computing...');\n    return n * 2;\n  };\n\n  // Memoized value\n  const result = useMemo(() => computeExpensiveValue(num), [num]);\n\n  return <p>Computed value: {result}</p>;\n};\n\nconst MyComponent = () => {\n  const [count, setCount] = useState(0);\n\n  return (\n    <div>\n      <p>Count: {count}</p>\n      <button onClick={() => setCount(count + 1)}>Increment</button>\n      <ExpensiveComponent num={count} />\n    </div>\n  );\n};\n```\n\n### Why Use `useMemo`?\n\n1. **Optimize Expensive Computations**: If you have a function or computation that is expensive to run, `useMemo` can help ensure it only runs when necessary, based on its dependencies.\n\n2. **Prevent Unnecessary Renders**: In some cases, you might be using a memoized value as a prop for child components. `useMemo` can help prevent those child components from re-rendering unnecessarily if the memoized value hasnâ€™t changed.\n\n### Example with List Filtering\n\nHereâ€™s an example where `useMemo` is used to filter a list of items. The filtering operation is only recalculated when the list or the filter criteria change.\n\n```javascript\nimport React, { useMemo, useState } from 'react';\n\nconst ListComponent = ({ items, filter }) => {\n  const filteredItems = useMemo(() => {\n    console.log('Filtering items...');\n    return items.filter(item => item.includes(filter));\n  }, [items, filter]);\n\n  return (\n    <ul>\n      {filteredItems.map(item => (<li key={item}>{item}</li>))}\n    </ul>\n  );\n};\n\nconst MyComponent = () => {\n  const [filter, setFilter] = useState('');\n  const [items] = useState(['apple', 'banana', 'grape', 'orange']);\n\n  return (\n    <div>\n      <input \n        type=\"text\" \n        value={filter} \n        onChange={(e) => setFilter(e.target.value)} \n        placeholder=\"Filter items\"\n      />\n      <ListComponent items={items} filter={filter} />\n    </div>\n  );\n};\n```\n\n### Summary\n\n- `useMemo` helps memoize computed values to prevent unnecessary recalculations.\n- It is useful for optimizing performance with expensive computations or when passing memoized values to child components.\n- Use `useMemo` with a dependency array to control when the value should be recalculated.",
    "questions": [
      {
        "question": "What is the purpose of the `useMemo` hook in React?",
        "choices": [
          "To manage state in functional components",
          "To memoize expensive calculations and improve performance",
          "To handle side effects in function components",
          "To create custom hooks"
        ],
        "correctAnswer": "To memoize expensive calculations and improve performance"
      },
      {
        "question": "When does `useMemo` recompute the memoized value?",
        "choices": [
          "On every render",
          "When the component unmounts",
          "When one of its dependencies has changed",
          "When the component receives new props"
        ],
        "correctAnswer": "When one of its dependencies has changed"
      },
      {
        "question": "What does `useMemo` return if the dependencies haven't changed between renders?",
        "choices": [
          "A new computed value",
          "A cached value from the previous render",
          "An error",
          "A function"
        ],
        "correctAnswer": "A cached value from the previous render"
      }
    ],
    "image": "/path/to/image11.jpg",
    "path": "/useMemo",
    "next": "/useCallback"
  },
  {
   "id": "react-14",
    "title": "useCallback in React",
    "content": "`useCallback` is a React hook that returns a memoized callback function. It is used to optimize performance by preventing unnecessary re-creations of functions during re-renders. This is particularly useful when passing functions as props to child components, which could otherwise cause those components to re-render unnecessarily.\n\n### Basic Usage\n\nTo use `useCallback`, pass a function and a dependency array to the hook. The function will only be recreated if one of the dependencies changes.\n\n```javascript\nimport React, { useCallback, useState } from 'react';\n\nconst MyComponent = () => {\n  const [count, setCount] = useState(0);\n\n  // Memoized callback function\n  const handleClick = useCallback(() => {\n    console.log('Button clicked!');\n  }, []); // Dependency array\n\n  return (\n    <div>\n      <p>Count: {count}</p>\n      <button onClick={() => setCount(count + 1)}>Increment</button>\n      <button onClick={handleClick}>Click me</button>\n    </div>\n  );\n};\n```\n\n### Why Use `useCallback`?\n\n1. **Preventing Unnecessary Re-renders**: When passing functions as props to child components, using `useCallback` can help avoid re-rendering the child components if the function reference doesn't change.\n\n2. **Optimizing Performance**: For performance-sensitive applications, especially those with many components or expensive re-renders, `useCallback` can help keep your application fast by minimizing unnecessary computations.\n\n### Example with Child Component\n\nConsider a child component that relies on a callback prop. Without `useCallback`, the child component would re-render every time the parent re-renders.\n\n```javascript\nimport React, { useCallback, useState } from 'react';\n\nconst ChildComponent = React.memo(({ onClick }) => {\n  console.log('Child component rendered');\n  return <button onClick={onClick}>Click me</button>;\n});\n\nconst ParentComponent = () => {\n  const [count, setCount] = useState(0);\n\n  const handleClick = useCallback(() => {\n    console.log('Button clicked!');\n  }, []); // Memoized function\n\n  return (\n    <div>\n      <p>Count: {count}</p>\n      <button onClick={() => setCount(count + 1)}>Increment</button>\n      <ChildComponent onClick={handleClick} />\n    </div>\n  );\n};\n```\n\n### Summary\n\n- `useCallback` helps memoize functions to prevent unnecessary re-creations and re-renders.\n- It is particularly useful when passing functions as props to child components.\n- Use `useCallback` with a dependency array to control when the callback should be recreated.",
    "questions": [
      {
        "question": "What is the primary use of the `useCallback` hook in React?",
        "choices": [
          "To manage state in functional components",
          "To memoize functions to prevent unnecessary renders",
          "To handle side effects in function components",
          "To create custom hooks"
        ],
        "correctAnswer": "To memoize functions to prevent unnecessary renders"
      },
      {
        "question": "When does `useCallback` update the memoized function?",
        "choices": [
          "On every render",
          "When the component unmounts",
          "When one of its dependencies has changed",
          "When the component receives new props"
        ],
        "correctAnswer": "When one of its dependencies has changed"
      },
      {
        "question": "How does `useCallback` help in optimizing child component performance?",
        "choices": [
          "By managing the child's state more effectively",
          "By preventing the child component from re-rendering unnecessarily",
          "By handling side effects in the child component",
          "By creating custom hooks for the child component"
        ],
        "correctAnswer": "By preventing the child component from re-rendering unnecessarily"
      }
    ],
    "image": "/path/to/image12.jpg",
    "path": "/useCallback",
    "next": "/useContext"
  },
  {
   "id": "react-15",
    "title": "useContext in React",
    "content": "`useContext` is a React hook that simplifies consuming context values in functional components. Context in React provides a way to share values between components without having to pass props manually through every level of the component tree.\n\n### Creating a Context\n\nFirst, create a context using `React.createContext()`. This context will provide a way to share values.\n\n```javascript\nimport React, { createContext } from 'react';\n\n// Create a Context with a default value\nconst ThemeContext = createContext('light');\n```\n\n### Providing Context Value\n\nUse the `ThemeContext.Provider` component to supply the context value to its descendants. This is usually done at a higher level in your component tree.\n\n```javascript\nimport React, { useState } from 'react';\nimport ThemeContext from './ThemeContext';\n\nconst ThemeProvider = ({ children }) => {\n  const [theme, setTheme] = useState('light');\n\n  return (\n    <ThemeContext.Provider value={theme}>\n      {children}\n    </ThemeContext.Provider>\n  );\n};\n\nexport default ThemeProvider;\n```\n\n### Consuming Context Value\n\nTo consume the context value in a functional component, use the `useContext` hook. Pass the context object to this hook to access the current context value.\n\n```javascript\nimport React, { useContext } from 'react';\nimport ThemeContext from './ThemeContext';\n\nconst ThemedComponent = () => {\n  const theme = useContext(ThemeContext);\n\n  return (\n    <div style={{ background: theme === 'dark' ? '#333' : '#fff', color: theme === 'dark' ? '#fff' : '#000' }}>\n      Current theme is {theme}\n    </div>\n  );\n};\n```\n\n### Summary\n\n- `useContext` allows you to access context values directly in functional components.\n- Create context using `React.createContext()` and provide it with `Context.Provider`.\n- Consume context values using the `useContext` hook to keep your component hierarchy clean and avoid prop drilling.",
    "questions": [
      {
        "question": "What does the `useContext` hook do in React?",
        "choices": [
          "It allows function components to access the context value directly",
          "It manages side effects in function components",
          "It creates a new context object",
          "It replaces the need for state management"
        ],
        "correctAnswer": "It allows function components to access the context value directly"
      },
      {
        "question": "How do you use the `useContext` hook?",
        "choices": [
          "By passing the context object to the hook",
          "By creating a new context inside the component",
          "By passing the component to the hook",
          "By calling it with no arguments"
        ],
        "correctAnswer": "By passing the context object to the hook"
      },
      {
        "question": "Why is `useContext` useful in React applications?",
        "choices": [
          "It helps manage component state",
          "It allows multiple components to share the same data without prop drilling",
          "It optimizes the performance of child components",
          "It handles side effects in components"
        ],
        "correctAnswer": "It allows multiple components to share the same data without prop drilling"
      }
    ],
    "image": "/path/to/image13.jpg",
    "path": "/useContext",
    "next": "/end"
  }
]
